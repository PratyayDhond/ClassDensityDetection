diff --git a/Makefile b/Makefile
index 09d790c..5246724 100644
--- a/Makefile
+++ b/Makefile
@@ -153,7 +153,7 @@ _%: %.o $(ULIB)
 _forktest: forktest.o $(ULIB)
 	# forktest has less library code linked in - needs to be small
 	# in order to be able to max out the proc table.
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o umalloc.o
 	$(OBJDUMP) -S _forktest > forktest.asm
 
 mkfs: mkfs.c fs.h
@@ -181,6 +181,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_testthreads\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -250,6 +251,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	testthreads.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
diff --git a/defs.h b/defs.h
index 82fb982..40b8fc1 100644
--- a/defs.h
+++ b/defs.h
@@ -10,6 +10,12 @@ struct sleeplock;
 struct stat;
 struct superblock;
 
+//Clone System Call
+int clone(void (*fcn)(void *, void *),void*arg1, void *arg2, void *stack);
+
+//Join System Call
+int join(void **stack);
+
 // bio.c
 void            binit(void);
 struct buf*     bread(uint, uint);
diff --git a/proc.c b/proc.c
index 806b1b1..39c989e 100644
--- a/proc.c
+++ b/proc.c
@@ -532,3 +532,109 @@ procdump(void)
     cprintf("\n");
   }
 }
+
+// Clone system call implementation
+int 
+clone(void(*fcn)(void*,void*), void *arg1, void *arg2, void* stack)
+{
+  struct proc *new_thread;
+  struct proc *current_thread = myproc();
+
+  if((new_thread = allocproc()) == 0)
+    return -1;
+
+  new_thread->pgdir = current_thread->pgdir;
+  new_thread->sz = current_thread->sz;
+  new_thread->parent = current_thread;
+  *new_thread->tf = *current_thread->tf;
+  
+  void * sarg1, *sarg2, *sret;
+
+  sret = stack + PGSIZE - 3 * sizeof(void *);
+  *(uint*)sret = 0xFFFFFFF;
+
+  sarg1 = stack + PGSIZE - 2 * sizeof(void *);
+  *(uint*)sarg1 = (uint)arg1;
+
+  sarg2 = stack + PGSIZE - 1 * sizeof(void *);
+  *(uint*)sarg2 = (uint)arg2;
+
+  new_thread->tf->esp = (uint) stack;
+
+  new_thread->threadstack = stack;
+
+  new_thread->tf->esp += PGSIZE - 3 * sizeof(void*);
+  new_thread->tf->ebp = new_thread->tf->esp;
+
+  new_thread->tf->eip = (uint) fcn;
+
+  new_thread->tf->eax = 0;
+
+  int i;
+  for(i = 0; i < NOFILE; i++)
+    if(current_thread->ofile[i])
+      new_thread->ofile[i] = filedup(current_thread->ofile[i]);
+  new_thread->cwd = idup(current_thread->cwd);
+
+  safestrcpy(new_thread->name, current_thread->name, sizeof(current_thread->name));
+ 
+  acquire(&ptable.lock);
+
+  new_thread->state = RUNNABLE;
+
+  release(&ptable.lock);
+
+  return new_thread->pid;
+}
+
+// Join system call implementation
+int
+join(void** stack)
+{
+  struct proc *thread;
+  int havekids, pid;
+  struct proc *current_thread = myproc();
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for(thread = ptable.proc; thread < &ptable.proc[NPROC]; thread++) {
+
+      // Check if this is a child thread (parent or shared address space)
+      if(thread->parent != current_thread || thread->pgdir != thread->parent->pgdir)
+        continue;
+        
+      havekids = 1;
+      if(thread->state == ZOMBIE){
+        // Found one.
+        pid = thread->pid;
+
+        // Remove thread from the kernel stack
+        kfree(thread->kstack);
+        thread->kstack = 0;
+
+        // Reset thread in process table
+        thread->pid = 0;
+        thread->parent = 0;
+        thread->name[0] = 0;
+        thread->killed = 0;
+        thread->state = UNUSED;
+        stack = thread->threadstack;
+        thread->threadstack = 0;
+
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || current_thread->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(current_thread, &ptable.lock);  //DOC: wait-sleep
+  }
+}
+
diff --git a/proc.h b/proc.h
index 1647114..8ca1791 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,7 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  void *threadstack;	       // Address of the thread stack
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..1713e56 100644
--- a/syscall.c
+++ b/syscall.c
@@ -82,6 +82,7 @@ argstr(int n, char **pp)
   return fetchstr(addr, pp);
 }
 
+
 extern int sys_chdir(void);
 extern int sys_close(void);
 extern int sys_dup(void);
@@ -103,6 +104,10 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_clone(void);
+extern int sys_join(void);
+extern int sys_gettid(void);
+extern int sys_tkill(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +131,10 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_clone]   sys_clone,
+[SYS_join]    sys_join,
+[SYS_gettid]  sys_gettid,
+[SYS_tkill]   sys_tkill,
 };
 
 void
@@ -143,3 +152,4 @@ syscall(void)
     curproc->tf->eax = -1;
   }
 }
+
diff --git a/syscall.h b/syscall.h
index bc5f356..afe9b1d 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_clone  22
+#define SYS_join   23
+#define SYS_gettid 24
+#define SYS_tkill  25
diff --git a/sysproc.c b/sysproc.c
index 0686d29..c63aee2 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -36,12 +36,28 @@ sys_kill(void)
   return kill(pid);
 }
 
+int 
+sys_tkill(void)
+{
+  int tid;
+
+  if(argint(0, &tid) < 0)
+    return -1;
+  return kill(tid);
+}
+
 int
 sys_getpid(void)
 {
   return myproc()->pid;
 }
 
+int
+sys_gettid(void)
+{
+	return myproc()->pid;
+}
+
 int
 sys_sbrk(void)
 {
@@ -89,3 +105,29 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int sys_clone(void)
+{
+	int func;
+	int arg1, arg2;
+	int stack;
+	
+	if(argint(0, &func)<0 || argint(1, &arg1)<0 || argint(2, &arg2)<0 || argint(3, &stack)<0)
+	{
+		return -1;
+	}
+	return clone((void *)func, (void *)arg1, (void *)arg2, (void *)stack);
+}
+
+int
+sys_join(void)
+{
+  void **stack_ptr;
+  int stack_arg;
+  stack_arg = argint(0, &stack_arg);
+  stack_ptr = (void**) stack_arg;
+  return join(stack_ptr);
+}
+
+
+
diff --git a/ulib.c b/ulib.c
index 8e1e1a2..df57d5b 100644
--- a/ulib.c
+++ b/ulib.c
@@ -1,8 +1,10 @@
 #include "types.h"
 #include "stat.h"
 #include "fcntl.h"
-#include "user.h"
 #include "x86.h"
+#include "user.h"
+#include "mmu.h"
+//#define PGSIZE 4096
 
 char*
 strcpy(char *s, const char *t)
@@ -104,3 +106,37 @@ memmove(void *vdst, const void *vsrc, int n)
     *dst++ = *src++;
   return vdst;
 }
+
+int thread_create(void (*start_routine)(void *, void *), void * arg1, void * arg2)
+{
+  void* stack_ptr;
+  stack_ptr = malloc(PGSIZE);
+
+  return clone(start_routine, arg1, arg2, stack_ptr);
+}
+
+int thread_join()
+{
+  void * stack_ptr;
+  int x = join(&stack_ptr);
+  return x;
+}
+
+
+int
+lock_init(lock_t *lock) {
+    lock->locked = 0;
+    return 0;
+}
+
+void 
+lock_acquire(lock_t *lock) {
+    while(xchg(&lock->locked, 1) != 0);
+}
+
+void 
+lock_release(lock_t *lock) {
+    xchg(&lock->locked, 0);
+}
+
+
diff --git a/user.h b/user.h
index 4f99c52..90146bc 100644
--- a/user.h
+++ b/user.h
@@ -1,5 +1,8 @@
 struct stat;
 struct rtcdate;
+typedef struct __lock_t {
+  uint locked;       // Is the lock held?
+}lock_t;
 
 // system calls
 int fork(void);
@@ -37,3 +40,15 @@ void* memset(void*, int, uint);
 void* malloc(uint);
 void free(void*);
 int atoi(const char*);
+
+int clone(void (*start_routine)(void *, void *), void *, void *, void *);
+int join(void **);
+int gettid(void);
+int tkill(int tid);
+
+int thread_create(void (*start_routine)(void *, void *), void * arg1, void * arg2);
+int thread_join();
+int lock_init(lock_t *lock);
+void lock_acquire(lock_t *lock);
+void lock_release(lock_t *lock);
+
diff --git a/usertests.c b/usertests.c
index a1e97e7..10a83ea 100644
--- a/usertests.c
+++ b/usertests.c
@@ -1737,13 +1737,6 @@ void argptest()
   printf(1, "arg test passed\n");
 }
 
-unsigned long randstate = 1;
-unsigned int
-rand()
-{
-  randstate = randstate * 1664525 + 1013904223;
-  return randstate;
-}
 
 int
 main(int argc, char *argv[])
diff --git a/usys.S b/usys.S
index 8bfd8a1..12f8bca 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,7 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(clone)
+SYSCALL(join)
+SYSCALL(gettid)
+SYSCALL(tkill)
